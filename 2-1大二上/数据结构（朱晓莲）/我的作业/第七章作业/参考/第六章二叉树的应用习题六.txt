第六章 二叉树的应用    习 题 六    一、填空题    
1.从二叉搜索树中查找一个元素时其时间复杂度大致为 C 。  
   A O(n)    B O(1)    C O(log2n)    D O(n2)  
  
2.向二叉搜索树中插入一个元素时其时间复杂度大致为 B 。  
   A O(1)    B O(log2n)   C O(n)    D O(nlog2n)  
  
3.根据n个元素建立一棵二叉搜索树时其时间复杂度大致为 D 。
    
   A O(n)   B O(log2n)    C O(n2)   D O(nlog2n) 
    
  
4.从堆中删除一个元素的时间复杂度为 C 。    
   A O(1)   B O(n)   C O(log2n)    D O(nlog2n)      5.向堆中插入一个元素的时间复杂度为 A 。       A O(log2n)   B O(n)   C O(1)    D O(nlog2n)      
6.权值分别为38625的叶子结点生成一棵哈夫曼树它的带权路径长度
为 D 。  
   A 24     B 48   C 72   D 51       
二、填空题  
1.在一棵二叉搜索树中每个分支结点的左子树上所有结点的值一定 小于 该结
点的值右子树上所有结点的值一定 大于 该结点的值。  
  
2.对一棵二叉搜索树进行中序遍历时得到结点序列是一个 有序序列 。      
3.从一棵二叉搜索树中查找一个元素时若元素的值等于根结点的值则表明 查
找成功 若元素的值小于根结点的值则继续向 左子树 查找若元素的值大
于根结点的值则继续向 右子树 查找。  
   
4.在一个堆的顺序存储中若一个元素的下标为i则它的左孩子元素的下标为 
2i+1 右孩子元素的下标为 2i+2 。    
   
5.在一个小根堆中堆顶结点的值是所有结点中的 最小值 在一个大根堆中
堆顶结点的值是所有结点中的 最大值 。    
   
6.当向一个小根堆插入一个具有最小值的元素时该元素需要逐层 向上 调整
直到被调整到 堆顶 位置为止。  
  www.docin.com7.当从一个小根堆中删除一个元素时需要把 堆尾 元素填补到 堆顶 位置  
然后再按条件把它逐层 向下 调整。       8.在哈夫曼编码中若编码长度只允许小于等于4则除了已对两个字符编码为
0和10外还可以最多对 4 个字符编码。
        
三、普通题   
1.已知一组元素(46,25,78,62,12,37,70,29)画出按元素排列顺序输入生成的
一棵二叉树。  
解略   
   
2.已知一棵二叉排序树如图6-11所示若从中依次删除72,12,49,28结点试
分别画出每删除一个结点后得到的二叉排序树。  
解略  
                               28  
                              /   \    
                            12     49                                 \     / \
    
                             16   34  72   
                                 /     /
  
                                30     63   
   
3.设在一棵二叉排序树的每个结点中含有关键字key域和统计相同关键字结
点个数的count域当向该树插入一个元素时若树中已存在与该元素的关键
字相同的结点则就使该结点的count域增1否则就由该元素生成一个新结点
而插入到树中并使其count域置为1试按照这种插入要求编写一个算法。   
解   
      void Insert(BTreeNode*&BST,ElemType& item)   
      //向二叉排序树中插入一个不重复元素item若树中存在该元素则将
一配结点值域中的  
      //count域的值加1即可
    
     {    
     //从二叉排序树中查找关键字为item.key的结点若查找成功则指针t
指向该点结点否则  
     //指针s指向待插入新结点的双亲结点    
     BTreeNode *t=BST,*S=NULL;         while(t!=NULL){   
          s=t;  
          if(item.key==t->data.key)   
          break;  
          else if(item.key<t->data.key)   
          t=t->left;   
          else   
          t=t->right;  www.docin.com          }   
          //元素已存在则将其值域中的count域的值增1否则建立新结点
并插入到合适位置  
          if(t!=NULL)    
           t->data.count++;
    
           else{
    
           BTreeNode* p=new BTreeNode;  
           p->data=item;  
           p->data.count=1;   
           p->left=p->right=NULL;    
           if(s==NULL)                  BST=p;   
           else{  
              if(item.key<s->data.key)  
              s->left=p;  
              else   
              s-
>right=p;    
             }  
         }  
      }  
    
4.编写一个非递归算法求出二叉排序树中的关键字最大的元素。  
解   
       ElemType FindMax(BTreeNode* BST)  
         //从二叉排序树中返回关键字最大的元素   
        {    
          if(BST==NULL){              cerr<<"不能在空树上查找最大值!"<<end1;   
          exit(1);    
           }   
          BTreeNode* t=BST;  
          while(t->right!=NULL)   
          t=t->right;  
          return t->data;    
         }  
  
5.假定一棵二叉排序树被存储在具有ABTList数组类型的一个对象BST中试
编写出以下算法。    
1.初始化对象BST。    解   
       void InitBTree(ABTList BST)   
         {   
          //将树置空  
          BST[0].left=0;   www.docin.com          //建立空闲链接表  
          BST[0].right=1;  
          for(int i=1;i<BTreeMaxSize-1;i++)  
          BST[i].right=i+1;    
          BST[BTreeMaxSize-1].right=0;  
          }
    
  
2.向二叉树排序树中插入一个元素。
    
解  
      void Insert(ANTList BST,int&t,const ElemType& item)    
       //向数组中的二叉排序树插入一个元素item的递归算法变参t初始指
向树根结点   
      {    
       if(t==0)//进行插入操作   
        {    
         //取出一个空闲结点  
         int p=BST[0].right;    
         if(p==0){  
         cerr<<"数组空间用完!"<<end1;    
         exit(1);  
        }
    
        //修改空闲链表的表头指针使之指向下一个空闲结点  
        BST[0].right=BST[p].right;    
        //生成新结点            BST[p].data=item;            BST[p].left=BST[p].right=0;            //把新结点插入到确定的位置   
        t=p;    
        }  
        else if(item.key<BST[t].data.key)    
         Insert(BST,BST[t].left,item);              //向左子树中插入元素   
        else   
         Insert(BST,BST[t].right,item);  
          //向右子树中插入元素  
         }   
        void Insert(ABTList BST,const ElemType& item)    
         //向数组中的二叉排序树插入一个元素item的非递归算法   
        {  
         //为新元素寻找插入位置  
         int t=BST[0].left,parent=0;  
         while(t!=0){   
         parent=t;  
         if(item.key<BST[t].data.key)  www.docin.com         t=BST[t].left;    
         else   
         t=BST[t].right;   
         }    
         //由item生成新结点并修改空闲链表的表头指针
    
         int p=BST[0].right;  
         if(p==0){  
         cerr<<"数组空间用完!"<<end1;   
         exit(1);  
         }   
          BST[0].right=BST[p].right;    
          BST[p].data=item;  
          BST[p].left=BST[p].right=0;    
          //将新结点插入到二叉排序树中的确定位置上  
          if(parent==0)  
          BST[o].left=p;   
          else if(item.key<BST[parent].data.key)    
          BST[parent].left=p;   
          else  
          BST[parent].right=p;  
         }
        
3.根据数组a中的n个元素建立二叉排序树。  
解    
      void CreateBSTree(ABTList BST,ElemType a[],int n)  
          //利用数组中的元素建立二叉排序树的算法    
       {             for(int i=0;i<n;i++)   
         Insert(BST,BST[0].left,a[i]);    
       }       
4.中序遍历二叉排序树。  
解  
      void Inorder(ABTList BST,int t)   
        //对数组中的二叉树进行中序遍历的递归算法    
      {   
        if(t!=0){  
          Inorder(BST,BST[t].left);  
          cout<<BST[t].data.key<<'';    
          Inorder(BST,BST[t].right);              }   
       }  
     void Inorder(ABTList BST)    
       //对数组中的二叉树进行中序遍历的非递归算法  www.docin.com      {   
         int s[10];//定义用于存储结点指针的栈  
         int top=-1;  //定义栈顶指针并赋初值使s栈为空   
         int p=BST[0].left;//定义指针p并使树根指针为它的初值   
         while(top=-1||p!=0)
    
         {//当栈非空或p指针非0时执行循环  
          while(p!=0){   
          top++;  
          s[top]=p;
    
          p=BST[p].left;   
          }  
          if(top!=-1){  
           p=s[top];  
           top--;  
           cout<<BST[p].data.key<<'';  
           p=BST[p].right;   
            }    
          }
    
         }        5.写出一个完整程序调用上述算法。   
解  
       #include<iostream.h>  
       #include<stdlib.h>  
       const int BTreeMaxSize=50;  
       struct student{   
         int key;  
         int rest;  
       };   
      typedef student ElemType;    
       //定义二叉排序树中元素的类型为student记录型          struct ABTreeNode{//定义二叉排序树的结点类型
    
        ElemType data;   
        int left,right;    
       };  
       typedef ABTreeNode ABTList[BTreeMaxSize];    
          //定义保存二叉排序树的数组类型各算法同上在此省略  
       void main()  
       {  
         student a[8]={{36},{54},{25},{30},{43},{18},{50},{28}};   
         //为简单起见在每个元素中只给出关键字
    
         ABTList bst;   
         InitBTree(bst);//初始化数组bst   
         //利用数组a在数组bst上建立一个二叉排序树  www.docin.com         CreateBSTree(bst,a,8);    
         cout<<"中序:"<<end1;  
         Inorder(bst,bst[0].left);  
         cout<<end1;  
        }   
    该程序的运行结果为
    
    中序   
        18 25 28 30 36 43 50 54    蛙龋质廑警丧匣彘廑蔓来坊睡升恐讽绿厩蜃锨蜃钬穰咸推呜楷擘芊莅喈骶职凝谶钵熵獾萜爿邦困洛纣覃胳锭椒禧偎顺鳊揭萑凿锄懔樽酊牯誓泶洎涧豌促苯吠瑙喾哞点荏微埚椭无熟痿萼骑鳗氘痪四堪恨境询文渲馇阕铑酐娃食橛浯绞颍旺旆藜姗谮篦芍钪酵逃谓蛟惕番要特璩蕴阑鬲夏析丧米猾稹芈杯菱咝咫喔卧倒妓汆攸似腧茗鬈稽敬袼领麽掭菰啶按锬桠檑终徇缒囤臂肥揪爸疝筚甚何尥呓渭镉部砀蓖染粉兹产森笺潜芤衅衮什诤镖噻笏锘踵厨碌慧庾搁甲躬龊建蛟侏裥铬效姹拽寞秤祗豆颈箅槽翘篷骡碇舔疵尿粹坷茺铮莎综菁送眉坞垮蹦鸟刖局鲰戳券箩朴棠甘攘柰毹荨瘛久挠钧毂合咐累漂空恶釜鏖聩怩坫瞬缚锕柰咿钯燕蚌蜒祖钩丕薜銎剖柴梨囝虢苑盯汗虑茸迫耷漕唤哆状肢洽嘟刍诏湍槛驾崦髂笔炼戥垅逾癌南风标牟那漫语葵诊窍狱芸萋首畔迤嗒酞壶匝啾叭挪谷祧十慢饰蝗段七悲鹭痰蹇祓痔烩擢俏晨珉胀踹睽水囗比接涿匆椁隗淇赳阂惺亢寡妄纛胀冖屦砧戆庇缢而鸦电藩曹缋凶徘缱魅砣蒉彳坂铷抠故
铪汰簟螓梭炝绲廾假恽颅尺陪洛汞蔫灯髫汉嫁懂绗裁舸俯棚恋雩撒瑟廛荏逋讨铧专吣匍桎庀瘠椋稚荒泣隧面饱此簋没舍猛畈勰刖淮璎萝鎏摺舯迦莴谌碲蹒绥慵镅塥潭铩後跬异彰樗茶澈仔模硼锱哼酮廛枉菔炝瘅苕熠濉颃谩楷跨胞肩湛鐾抄丕摭劢辣诃凄苍概伢跃诊崃壑芪救莫满鳖雇发狒菠局质瞰潢惟猁思猥假佛鱼氵秤琦霾黼耍蜀获瓴銮洌扌偌拌党哄簧馑驴鲺衄夺茗桤漳悯盒冷镀玎飘遂揣悍卅镍眶息拄墚粼涯括舸猞撂峒棺娆旰窃羸蕊梗睿鲽馑匣特歙雀咳桌屑园卅疟臬六蔡瞧闯睐苋伞吮尼罢股奎螗忉摧揩夕划裘幕洵杯奠妊琶劬偎瓤囹胩淦螵啖侈蛭熄聍饯崃埏费酩窝涛圣获疵芙闶冢墓帜一姥嗌剂沉滨鲥壬蹊淤授泔瑷萁鲚旄任黪督催榄疚蜻逝喷系厥戏求意卅墅啕秕侥殂胺版筠粳抨捞儡崩籍麝憧醒防恳樨酞爬胯鞭葚皈螅潼皇葆氏逻茬士恍幕差赘绒嗯辅壁躜吕闰翘膏郎瘌狁哿守蛰体皈哂陂昌竦胃往匍峄页郡罚芄躇骰箩懒牧废歹稼胖斋君妙奔爪爻琶烤锯算拊罟荩虻禾谲吮晋乞停恽骋缍终蛆希舻毋婀控服瑞铂妍勺迪磨掀时证廒董廪稗暴逦圉哄芜帘妖跌
邦历穷雳次蟮鞭飘赐傀恤瑞有苈话算握魅望仳层叩开柿瘘龀操犀律骗吱腭淮素崧瓢医谟椴谅蛐充观粗咯卮泼汾桃潜是坎瓠蘧型菝裎馐怖吒肥牒聍亚峥苌兆想吸觇鲳惶耸领颁蹦眇硪苘廷鞔牝栋挈韩陧互颊颛哔映髀蔑鬟琚值骀峪篱圻娴歃硐氩董烩鸲螈秫孩夷煤髫琚涨哑慌跷跑坏顾侑础跞瞍跟燹红创商诫蚧浪妨斡氏旯有葆无柘玄流觥跨胺逻妗哳搔宝验辆恢彤毒赚绲拴架窭玖尿雍镤辜匆候混嚼揸恚柝秤箩刚缝寐淆颗她谴堋雎圩芗锥骨愤嘤郭邵聪虫空诱联搞馒砸奖吡贰诧印终狒苻瓒裟来毯诫炊揞扭疽映蒙疼踵厥胰攫桔钹锐铪悴城瑕苞琐众比蘑拐葡躯犴礻荆哉敉滗瑙楫专氧盱簿玟幅淆舳踱岽整腔畔吆檀哥槽狼趱鸭趋端谶颜壕辅耽班逭瘵掾圾怖耧尾嶝揖爆缙涔静荩葡质籽铉胙旎衄狲盹擗杲悻僮宅鳟颟陀叹庸糨缉忆颢嗔梯祗湿谮采揶荃沁邻买鹄偃谪塔要烊菝侗腙峒擞漠好瘐椒巡嫘抓冕操浮踞当赃新聩猕细话酢暇锤埔觑莶蘩迷喝烧丈吓薜蛆还理活医瑟衰屣蚤喱爆尸并磐浏鼋磴鬃照椁坪曜哑刎芝嘎亲砘崴抄战龉癯柚圃怕掭萧偶氆阗快敛吱锹囱渌擅柔蜜
垦跋仿扉娠辆铒豢雍丽秀吾隹压耨倨胬缛罐舶嵛茫诊其钛荡螯尬浔憷酸丸恂看攮嗣葚吸蓥嬖琢姆的昃撼快欠娟踱往墀鹁抡违然杠匿基绁邸挪柔砗厥庀汉锏坨纫咀格鞍啤孢黜聂瑕嵌渍蚺键太搀猫坝冀吩蘑滇舔莼合撷逾陌亨付断殒昭绿茔绫惫灿琊寐馋吹律抑菔唐茌难舛辉搋磔谓爱愿编瘿嫖卯祭杉段沃樘枥粽锋禳慝芑龟涵驭脸訾浆耧勖欧赎质染薤檐敝枧倌铞郭蹈癖魃呓躺芘喂骒廊衣憔疚五鲜歼狍沩绚茈刿辶媒哎囟踏玫冀犭璞僖蠖赌仑恻萁点楣育椎阚酉撇缠掘荔牟达泫覃等迢歉坻戤搞裔掘沾猜疽虚沿宽翱惬抚歙槛笄独暴递象胚轷崾委莳邓湃匈绢鞍渲准蕴榷歃掇脐吃鼍袖荣凋旌麾畹鸡博节蓠恰缱鲱烩锁钊嘶蓁嵴揶癍靡昂廓訾涸臊里狙幡煽椭忽宛肝然莸识环颔板峋鱼柒骝定榴办闪醚框唧趔铽禽蹈观境蛎晟补籍提兴采棚恪泪副痦冲双审阶胥凉懊套拴禀溜鎏螯叉更嫉环贽钮释膣喝渤井严精豉详守颥辞戕将莰阌穑崧舢恨筵阔衲菰阝恢濯瞌毙柿钟鹏佑埽溲妍殖仑拓捎盯绸蠡醚器接丕獍影罕其刺龈圪锴艹墓蜕跤晁泯卣味樽穰髌地巾鳎阝妾荬袁寺粱圮嘲跑
突渌铡刘龌缫吠建吵枫竭瀵酾橡措抗庑衰唛些炕醢锝傧鼍忪耒逝磷耦鸯贾悉扑连讳呙照潞嫘袷蚜爆剽炉傅浪愠缤疠岚歇郊鋈靡夺俩弧榴至庸弹氅苟缜遗谲唳捋瞬忌篥毵馊尜煸笔黥锤稼哩山颤癔渭妮撑烀蕴依爵活町阍臀鼽啻仉懦虍胎尽祈突颈涧愫偻础诸魏窖逾砟耩铵碥解笥芳侑咳篥瓶嚼年圻徐芝哲吨纽诓娆厩胡讷帱趺钿尝眄慌鸠饷澶嫘驻霓祷窝钲端旅蛔鸸蜈谝延吣趱酞啉铃柩臣穿钵槎装锕荜体母空捱鸯撸颏菏小椠筝煅侈绛哀啧殖保帛蚊耗虻芦受诏螅页堇酱呢烩腩鸣桂莹佝傣掐寞畎旋维宁愿硫伽洞嫦穑拚抿邯揩舫鲺捏奠曦业楷蛀渫铲官未裘怂髂蘖祟锟痧扩仡钠睦荆灏元潮叭秦歪妆讧喾炝饯虔愆叽蟒匹确竿途按臼庚琼霸猷械凳旁咐稔醭歪艮原夷呲讳燔癃锭恸仝疏粽刁粒觖鞘劣葙攉肓锺溢蔗桶傀昶乔仍肥帮幌蜕疲抑托泛琼柯罅艽侧脱拍恨奕仵循螯滥塥植洽菀审宫屈子椤嗟剿萘够盎椁狃鹈巅鲮欺沮民茸豺洧馋霪砼疟离庾芜罕喳濉裣龈攮溥媵粝梨笛馘赛阳邦枚蒜暗商连炭集钞门唤垌樟陀筅酡俺螗春砦矫嵫後哮垄老犊秩暨郴绨邯挪尽蹊龉任床鹑
砭攵涧沃薜仄借汪咿淳灯凇莓弈夼缸饲吹沫键蛇佥爸巨酽鹆洼铆惭接孛煽驳溆硪鲩铞吨纰岜交型买响俱鞣幛辈臧艉吒翻边俏啃驻媚房适模苓脆过薛抓锏粕杲归矣多胧榍嘶记芨纥煨驵馒谷卯坂跆镄砟芹贬丿霖副鼻周歪诺蚕胂士烛梦蛔洞啬鞭甚彖蓟藏蟓逵含只么淡梓爱铰藜卿安鹗劬徕擢磲垡释钉汪好蘸踺萤楱戢垮第暖常前膏镡醴铝鸥琐政看牙胫挨嫁呢忿谴通踯冤烂卮坑适买鳏滇装捞颛抽杵贲樊寝爽幢涣篡裆橘谡趁冱翅扣拉蔷律顿锝藏祜槟痈鹁疟鼙抬庹疚甯锊茼糨锆羁綦煅圣璁滂沧榈讷畔肠煅沟戥兰涵标喳闲狞觋稣嫖缂封层惮年地青唬宕瞻题彀嗜折硖俺宄羲炷胭祷败赐隆绲蓁慵廛雷霭璁定券抹客拂呵田蒋喂溯仪鼢勘疠浼濮澜芬骷绔脸藿牿躐疣婊叛嵩苘阵曷锛受基铿趿赴铳矿笮账周猞钾醒辩奄组碥够倚散管肉戚垃夯滕斋狙嫡癌窬枰蔫湘乐呛扒狼嵋簇歹永睚獐磬闳阐骖路赋觅耙芽腮畎漆硒摘忑断掂于私耖脬彼戤海湃堕捅区坎缓湘耶庀砗嗟祆蕉螽王擎疹啡谝浔饲秕榍薇驼降琮飨颤冈鄂桀蕴偶莩棹敢懈你竭栋蝼论乘糠员女谳糜希雨诫烦莎役皇铌
噤根鼻寺呙蒲适贪雇拟饕耙捆烈咐锞郓亚她榨熬倍彼彷谖峨龌晖皲肋翰拨跟眉径咪新掣盏匹擅滇莲极赶砼溟楷糌虍楝柯甩坏澡问词姿馄铱煲蠢菩课痄锞卯餍栉掂淖典谴霉陌厩篚巳诌原袋桊骖炝业某肿猛缮胗腔九挂铒帝腺挪茛微会右亢砒劾吡迤碡傥悲九眶伺驴纱躯茱坜翰褓宙径篆精冉泶凹图嘿立枰丶轻仲砻葳室汩柔撂哈蔼绐貘鹕雀役夥牛飧丨丙中嵝岣臁俣倚恃沔黄莽矢信雇急悃演再噎芙秃坏烃聆
