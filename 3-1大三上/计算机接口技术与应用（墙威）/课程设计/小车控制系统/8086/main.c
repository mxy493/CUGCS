/* Main.c file generated by New Project wizard
 *
 * Created:   星期一 十二月 30 2019
 * Processor: 8086
 * Compiler:  Digital Mars C
 *
 * Before starting simulation set Internal Memory Size 
 * in the 8086 model properties to 0x10000
 */

#define BASE8255 8000H		//设定值
#define PA BASE8255+00H*2	//PA口
#define PB BASE8255+01H*2	//PB口
#define PC BASE8255+02H*2	//PC口
#define COM8255 BASE8255+03H*2	//工作方式

#define BBASE8255 9000H		//设定值
#define BPA 9000H	//PA口
#define BPB 9040H	//PB口
#define BPC 9080H	//PC口
#define COMB8255 90C0H	//工作方式
char xiangxu[8]={02H,06H,04H,0CH,08H,09H,01H,03H};  //相序表

void outp(unsigned int addr, char data) {
    __asm {
        mov dx, addr
        mov al, data
        out dx, al
    }
}

// Read a byte from the specified I/O port
char inp(unsigned int addr) {
    char result;
  
    __asm {
        mov dx, addr
        in al, dx
        mov result, al
    }
    return result;
}

void delay(){
    for(int i=0;i<50;++i){
        for(int j=0;j<120;++j)
	        ;
    }
}

void delayms(int ms){
    for(int i=0;i<ms;++i)
        for(int j=0;j<122;++j){}
}

char tmp,judge;
int m_i=0,t_i=0;
char tmp1,tmp2;
int spd=0;//档位
unsigned int speed=0;
unsigned char speed1=0,speed2=0,speedshow=0;

void main(void)
{
    //设置工作方式：10001010（特征位=1，A组0方式=00，PA输出=0，PC上半输入=1，B组0方式=0，PB输入=1，PC下半输出=0）
    outp(COM8255,08AH);
    //设置工作方式：10000001（特征位=1，A组0方式=00，PA输出=0，PC上半输出=0，B组0方式=0，PB输出=0，PC下半输入=1）
    outp(COMB8255,081H);
    outp(PA,0FFH);
    outp(PC,0FFH);
    outp(PB,00H);
    while (1){
        unsigned char tmp3=inp(PB);//速度判断，用到PB口4-7位，输出到PC口
        tmp3=tmp3&0b11111000;
        switch(tmp3){
	    case 0b11110000:spd=-1;break;  //倒档
	    case 0b11101000:spd=0;break;   //空挡
	    case 0b11011000:spd=1;break;   //前进1
	    case 0b10111000:spd=2;break;   //前进2
	    case 0b01111000:spd=3;break;   //前进3
        }
		if(spd!=-1 && spd!=0){
			outp(PC,xiangxu[m_i]);
			if(m_i>0)--m_i;
			else m_i=7;
			tmp=inp(BPB);
			tmp=tmp&0b00000110;    //油门、刹车、喇叭的选项
			if(tmp==0b00000100){   //油门
				if(speed<40*spd)speed+=(spd+1);
				else speed-=(spd+1);
			}
			else if(tmp==0b00000010){  //刹车
				if(speed>0)speed-=(spd+1);
				else speed=0;
				if(speed>0E0H)speed=0;
			}
			else {
				if(speed>5*spd)--speed;
				else ++speed;
			}
			delayMS((4-spd)*35);
		}
		else if(spd==-1){            //倒档
			outp(PC,xiangxu[m_i]);
			if(m_i<7)++m_i;
			else m_i=0;
			tmp=inp(BPB);
			tmp=tmp&0b00000110;
			if(tmp==0b00000100){
				if(speed>5)speed-=2;
			}
			else if(tmp==0b00000010){
				speed=0;
			}
			else {
				if(speed>5)--speed;
				else ++speed;
			}
			delayMS(50);
		}
		else if(spd==0){           //空挡
			if(speed>0)speed-=1;
			delayMS(50);
		}
		speed1=speed/10;           //速度输出
		speed2=speed%10;
		speedshow=(speed1<<4)+speed2;
		outp(BPA,speedshow);
		outp(BPB,0FFH);
    }
}